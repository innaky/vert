* WORK IN PROGRESS
This document is a work in progress. Please do not take it seriously.
* Units
** Distance
** Time
Unless otherwise stated in the variable name, all time units are assumed to be milliseconds.

#+BEGIN_SRC lisp
*start-time* ; assumed to be milliseconds
*start-time-ms* ; explicitly milliseconds
*start-time-seconds* ; explicitly seconds
#+END_SRC
*** Wallclock time
TICKS and TICKS-NANOS return a millisecond and nanosecond timestamp respectively. This timestamp begins counting from an arbitrary point in time.

#+BEGIN_SRC lisp
(ticks) ; -> ms timestamp
(ticks-nanos) ; -> nanosecond timestamp
#+END_SRC
*** Scene Time / Game Time
The amount of wallclock time passed will often not equal the amount of "game time" elapsed. For example, if the game is paused while an attack is charging, the amount of time paused must not affect the game-object's charge time.

Each scene has a SCENE-TICKS function, which returns the amount of milliseconds elapsed since the scene began running.

You will almost always want to use SCENE-TICKS to implement in-game timers.
#+BEGIN_SRC lisp
;; *scene* begins running
(scene-ticks *scene*) ; -> 0
;; 4 seconds of game time have elapsed
(scene-ticks *scene*) ; -> 4000
;; game is paused for 5 minutes, then unpaused
;; *scene* internal timer is the same because it was not recieveing updates while paused.
(scene-ticks *scene*) ; -> 4000
#+END_SRC
* Event System
** scratch
Goals:
- object instance can subscribe to another object instance
  - e.g. scene subscribes to objects getting killed
- object instance can subscribe to a type of event
  - e.g. scene subscribes to a screen resize and pauses itself
- anonymous callbacks to events
  - e.g. on-engine-start event, set up the resource-autoloader

#+BEGIN_SRC lisp
  (publish-event GAME-WINDOW-RESIZED new-width new-height)
  (publish-event GAME-WINDOW-MOVED new-x new-y)

  ;;;; low level
  (defparameter *pending-events*
    (make-some-array)
    "Events which will be published next frame.")

  (defparameter *event-bus*
    (make-some-array)
    "Events which have been published in the previous update frame.")

  (defun publish-event (event-name-symbol &rest event-args)
    ;; push event name and all args to pending-events
    )

  ;;;; event api

  ;; define a type of event
  (defevent game-window-resized (old-width old-height new-width new-height)
      "docstring")

  ;; next frame run the game-window-resized event
  (publish-event game-window-resized 100 75 200 150)

  ;; how sprites will react to window resizes
  (defevent-callback game-window-resized ((sprite static-sprite) old-width old-height new-width new-height)
    )

  ;; function which runs every time the window is resized
  (on-event game-window-resized (old-width old-height new-width new-height)
    (log:info "game window resized"))

  ;; TODO how to subscribe to a particular instance

#+END_SRC
** Subscribing to a type of event
** Subscribing to Events from a specific instance
* Vert Systems
** Config
*** Interesting Globals
** GL Context
** Audio
** Caches
** Resource Autloader
** Everything else
* Game-Object and Scene
** Game-Object
** Game Components
*** Transform
*** 2D Physics
*** Sprite Rendering
*** Font Rendering
*** Instanced Sprite Rendering
*** State Machine util
** Components which load external resources
Scenario: your game component requires external resources (CFFI array, opengl bits, sfx bits).

Your component must:
1. Not attempt to load these bits when initialized. You should be able to create your component without a game window, gl-context, audio buffer, etc.
2. When the engine starts, load the appropriate resources
3. When the engine stops, release the appropriate resources
4. When the component is dereferenced, release the appropriate resources before the engine shuts down

*** Recommended Approach
How resources are managed is ultimately up to the component developer, but it is highly recommended to do the following:
1. Hook LOAD-RESOURCES and RELEASE-RESOURCES for your component (either use an :AROUND, :AFTER, or simpley CALL-NEXT-METHOD)
2. When the object is initialized, register it with the *RESOURCE-AUTOLOADER*
3. When the object's resources are loaded, use the RESOURCE-RELEASER util to add a finalizer to the object's resources if it is dereferenced
4. When the object's resources are released, cancel the resource releaser

As an example, we'll consider a bomb component. This is a contrived example for educational purposes. In practice the rendering and audio logic would be broken out into simpler utility components which manage the underlying bits.
#+BEGIN_SRC lisp
  (defclass bomb (game-object)
    ((releaser :initform nil)
     (spritesheet :initform nil)
     (explode-sfx :initform nil)))))

     ;; Note: Hooking :AROUND so that all initializations are complete before resource-autoloader potentially call LOAD-RESOURCES
  (defmethod initialize-instance :around ((bomb bomb) &rest args)
    (declare (optimize (speed 3)))
    (let ((all-args (append (list bomb) args)))
      (prog1 (apply #'call-next-method all-args)
        (resource-autoloader-add-object *resource-autoloader*
                                        (tg:make-weak-pointer bomb)))))

  (defun %release-bomb-resources (spritesheet explode-sfx)
    (release-spritesheet spritesheet)
    (release-sfx explode-sfx))

  (defmethod load-resources ((bomb bomb))
    ;; first make sure parent loading works
    (prog1 (call-next-method bomb)
      (unless (slot-value bomb 'releaser)
        (let ((spritesheet (make-spritesheet *gl-context* (resource-path "./art/bomb.png")))
              (explode-sfx (make-sfx *audio* (resource-path "./sfx/explode.wav"))))
          (setf (slot-value bomb 'spritesheet) spritesheet
                (slot-value bomb 'explode-sfx) explode-sfx
                (slot-value bomb 'releaser)
                ;; Note that passing BOMB will NOT create a hard ref.
                (make-resource-releaser (bomb)
                  (%release-bomb-resources spritesheet explode-sfx)))))))

  (defmethod release-resources ((bomb bomb))
    (with-slots (releaser spritesheet explode-sfx) bomb
      (prog1 (call-next-method bomb)
        (when releaser
          (%release-bomb-resources spritesheet explode-sfx)
          (cancel-resource-releaser releaser)
          (setf releaser nil
                spritesheet nil
                explode-sfx nil)))))
#+END_SRC
** Scenes
*** GAME-SCENE
*** Menu
*** Pause Scene
*** Overlays
